# SPEC-003: Claude Code 执行模型与分析框架

> 作者: Boris Huai
> 起草日期: 2026-01-25
> 修订日期: 2026-01-25
> 版本: 2.0
> 状态: 实施中

---

## 修订历史

| 版本 | 日期 | 变更 |
|------|------|------|
| 1.0 | 2026-01-25 | 初版，提出五阶段执行模型 |
| **2.0** | 2026-01-25 | **重大修订：区分"真实执行流"和"分析框架"** |

---

## 背景

原有的七步骤模型是一个理想化的线性流程，无法反映 Claude Code 的真实工作方式。

v1.0 版本提出的五阶段模型（理解→探索→规划→执行→验证）是一个改进，但在实践中发现：

1. **简单任务不遵循五阶段**：如 `/report` 直接并行执行 11 个命令，无"探索"和"规划"
2. **阶段边界模糊**：实际执行中阶段交织、跳跃，不是离散切换
3. **强制套用导致失真**：让 Agent "表演"预设流程，而非记录真实行为

**本次修订的核心变化**：

> 五阶段模型从"执行约束"降级为"分析框架"。
> 真实执行流（工具调用序列）是第一公民。

---

## 核心概念区分

### 真实执行流 vs 分析框架

| | 真实执行流 | 分析框架 |
|---|---|---|
| **本质** | 实际发生的事 | 对执行的解读 |
| **数据** | 工具调用序列 | 阶段标注 |
| **属性** | 客观、可验证 | 主观、可争议 |
| **必要性** | 必须记录 | 可选标注 |
| **来源** | 系统自动捕获 | Agent/人类/算法事后标注 |

### 示例对比

**真实执行流**（必须记录）：
```
tool-001: Bash("find ... wc -l") → "1870"
tool-002: Bash("find ... wc -l") → "19"
...
tool-011: Bash("find ... wc -l") → "12"
```

**分析标注**（可选）：
```
无标注。任务太简单，不值得分析。
```

或者对于复杂任务：
```
ann-001: tool-001 ~ tool-004 → "explore" (置信度: high)
ann-002: tool-005 ~ tool-008 → "execute" (置信度: high)
```

---

## Claude Code 核心能力

### 工具集 (Tools)

| 类别 | 工具 | 作用 |
|------|------|------|
| **感知** | `Read` | 读取文件内容 |
| | `Glob` | 按模式搜索文件 |
| | `Grep` | 按内容搜索文件 |
| | `LSP` | 代码智能（定义、引用、符号） |
| | `Bash` (查询类) | 获取环境状态 |
| | `WebFetch` | 获取网页内容 |
| | `WebSearch` | 搜索网络信息 |
| **行动** | `Write` | 创建文件 |
| | `Edit` | 修改文件 |
| | `Bash` (执行类) | 运行命令 |
| | `NotebookEdit` | 编辑 Jupyter notebook |
| **交互** | `Task` | 委托子 Agent |
| | `AskUserQuestion` | 向用户提问 |
| **规划** | `EnterPlanMode` | 进入规划模式 |
| | `ExitPlanMode` | 退出规划模式 |
| **任务管理** | `TaskCreate` | 创建任务 |
| | `TaskUpdate` | 更新任务 |
| | `TaskList` | 列出任务 |

### 上下文来源 (Context Sources)

| 来源 | 内容 | 持久性 |
|------|------|--------|
| 对话历史 | 用户消息、助手回复、工具结果 | 会话内持久 |
| CLAUDE.md | 项目规则、约束、偏好 | 跨会话持久 |
| 文件系统 | 代码、配置、文档 | 持久 |
| 工具结果 | 每次工具调用的返回 | 临时 |
| 系统提示 | 角色定义、能力边界 | 固定 |

### 推理能力 (Reasoning)

- 意图识别：理解用户真正想要什么
- 任务分解：将复杂任务拆分为步骤
- 工具选择：决定使用哪个工具
- 参数构造：生成工具调用参数
- 错误诊断：分析失败原因
- 方案调整：根据反馈修正策略

---

## 真实执行模型

### 核心循环：感知-推理-行动 (PRA Loop)

这是 Claude Code 的**真实**执行模式：

```
┌─────────────────────────────────────────────────────────────┐
│                        用户输入                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  ┌─────────┐    ┌─────────┐    ┌─────────┐                 │
│  │  感知   │───▶│  推理   │───▶│  行动   │                 │
│  │Perceive │    │ Reason  │    │   Act   │                 │
│  └─────────┘    └─────────┘    └─────────┘                 │
│       ▲                              │                      │
│       │         工具调用结果          │                      │
│       └──────────────────────────────┘                      │
│                  PRA 循环                                   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                        输出响应                              │
└─────────────────────────────────────────────────────────────┘
```

### 执行流特征

1. **工具调用是原子单元**：每次工具调用都是独立、可观测的事件
2. **并行执行**：无依赖的工具调用可能同时发起
3. **动态决策**：下一步行动取决于上一步结果
4. **无固定阶段**：不存在"现在进入探索阶段"的切换点

### 不同任务的执行模式

| 任务类型 | 典型执行流 | 阶段特征 |
|----------|-----------|----------|
| 简单查询 | 1-3 个工具调用 | 无明显阶段 |
| 信息收集 | 多个 Read/Glob/Grep | 全是"探索" |
| 代码修改 | Read → Edit | 探索+执行，无规划 |
| 复杂功能 | 多轮探索→规划→执行→验证 | 完整五阶段 |
| 调试修复 | 循环：Read→假设→Edit→测试 | 阶段交织 |

---

## 五阶段分析框架

### 定位

五阶段是一个**分析工具**，用于：
- 事后理解 Agent 行为
- 教学和解释
- 可视化分组
- 行为模式研究

**不是**执行约束或预设流程。

### 阶段定义

#### 理解 (Understand)

**特征**：解析用户意图，无工具调用或仅读取用户消息相关内容

**识别信号**：
- 会话开始的第一个推理
- 用户消息后的意图分析

#### 探索 (Explore)

**特征**：构建上下文，大量感知类工具调用

**识别信号**：
- 连续的 Read/Glob/Grep/LSP 调用
- WebSearch/WebFetch 调用
- 未产生文件修改

#### 规划 (Plan)

**特征**：决定执行方案，通常无工具调用

**识别信号**：
- EnterPlanMode/ExitPlanMode 调用
- 明确的步骤分解输出
- TaskCreate 批量创建任务

#### 执行 (Execute)

**特征**：实施修改，大量行动类工具调用

**识别信号**：
- Write/Edit 调用
- Bash 执行命令（非查询）
- 文件系统变更

#### 验证 (Verify)

**特征**：确认结果，检查类操作

**识别信号**：
- Bash 运行测试/类型检查
- Read 确认修改内容
- 用户反馈后的检查

### 标注置信度

| 置信度 | 含义 | 示例 |
|--------|------|------|
| high | 明确属于该阶段 | 连续 5 个 Grep 调用 → explore |
| medium | 大概率属于该阶段 | Read 后立即 Edit → 可能是 explore+execute |
| low | 难以判断 | 单个 Read 调用 → 可能是任何阶段 |

### 标注规则

1. **不强制覆盖所有调用**：部分调用可以不标注
2. **允许重叠**：同一调用可能属于多个阶段
3. **允许缺失**：简单任务可能无任何阶段标注
4. **标注来源透明**：记录是 Agent/人类/算法标注的

---

## 可视化设计建议

### 主视图：工具调用时间线

工具调用流是**主视图**，按时间排列：

```
时间轴
  │
  ├─ [Glob] **/TimelineNode*        ← 感知
  │     └─ 返回: 2 个文件
  │
  ├─ [Read] TimelineNode.tsx        ← 感知
  │     └─ 45 行代码
  │
  ├─ [Read] SPEC-002.md             ← 感知
  │     └─ 颜色规范
  │
  ├─ [Write] KnowledgeMarkers.tsx   ← 行动
  │     └─ 创建成功
  │
  └─ [Edit] TimelineNode.tsx        ← 行动
        └─ 添加 import + 调用
```

### 叠加层：阶段标注（可选）

阶段标注作为**叠加层**，可隐藏：

```
时间轴                              阶段标注
  │                                   │
  ├─ [Glob]  ─────────────────────── │ explore
  ├─ [Read]  ─────────────────────── │   │
  ├─ [Read]  ─────────────────────── │ ──┘
  │                                   │
  ├─ [Write] ─────────────────────── │ execute
  └─ [Edit]  ─────────────────────── │ ──┘
```

### 简化视图：无阶段

对于简单任务，直接展示工具调用：

```
/report
  │
  ├─ [Bash] wc -l *.ts → 1870
  ├─ [Bash] wc -l *.ts → 19      (并行)
  ├─ [Bash] wc -l *.css → 1752   (并行)
  ├─ ...
  └─ 输出: 统计报告
```

### 上下文视图：知识累积

```
┌─────────────────────────────────┐
│ 上下文 (Context)                 │
├─────────────────────────────────┤
│ [file] TimelineNode.tsx         │ ← tool-002 贡献
│ [spec] SPEC-002.md              │ ← tool-003 贡献
│ [claude_md] CLAUDE.md           │ ← 自动加载
│ [user] 用户最近消息              │
└─────────────────────────────────┘
```

---

## 关键洞察

### 1. 工具调用是真相

可视化应该展示**实际发生了什么**，不是**我们认为应该发生什么**。

### 2. 阶段是解读，不是事实

"这是探索阶段"是一个**判断**，不是**记录**。不同人可能有不同解读。

### 3. 简单任务不需要阶段

强制给 `/report` 标注五阶段是过度分析。有时候"执行 11 个命令，输出结果"就是全部。

### 4. 复杂任务阶段有价值

对于 30+ 工具调用的复杂任务，阶段标注帮助理解整体结构。

### 5. 上下文累积是核心

每次工具调用的结果累积到上下文，构成 Agent 的"工作记忆"。这是可视化的重要维度。

---

## 与其他文档的关系

### STD-001 v3.0

本文档的理念在 STD-001 v3.0 中落地：
- `tool_calls[]` 是核心必须字段
- `phase_annotations[]` 是可选字段
- 支持无阶段标注的简单任务

### CLAUDE.md

CLAUDE.md 中的"执行模型"章节应理解为：
- 五阶段是**分析框架**，用于理解 Agent 行为
- 不是**执行约束**，Agent 不需要"按阶段执行"

---

## 开放问题

1. **自动标注算法**：是否实现基于启发式的自动阶段标注？
2. **标注 UI**：是否提供人工标注工具？
3. **多人标注**：如何处理不同人对同一 Session 的不同标注？
4. **可视化默认**：默认显示工具流还是阶段视图？

---

## 相关文档

- [SPEC-001: 项目总览](./SPEC-001-project-overview.md)
- [SPEC-002: 可视化界面设计](./SPEC-002-visualization-design.md)
- [STD-001: Agent Session 日志记录标准](../../standards/data/STD-001-agent-session-logging.md)
- [STD-001-Evolvable-1: 日志标准演进说明](../../standards/data/STD-001-agent-session-logging-Evolvable-1.md)
